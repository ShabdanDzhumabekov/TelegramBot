class Connection:
    __slots__ = ['connection', 'cursor']

    def __init__(self):
        pass
        #self.connection = conn
        #self.cursor = conn.cursor()
        #print("Database opened successfully")

    # блок создания
    def create_access(self):
        self.cursor.execute('''
            CREATE TABLE access(
            USER_ID BIGINT,
            CODE BOOLEAN DEFAULT FALSE,
            constraint pk_access PRIMARY KEY(user_id))
            ''')
        self.connection.commit()
        self.create_position()

    def create_position(self):
        self.cursor.execute('''
        create table position(
        user_id bigint,
        pos int,
        constraint pk_position PRIMARY KEY(user_id),
        constraint fk_position_access foreign key(user_id)
        references access(user_id)
        on delete cascade)
        ''')
        self.connection.commit()

    def create_students(self):
        self.cursor.execute('''
                create table students(
                name text not null,
                surname text not null,
                midname text,
                record_num bigint,
                user_id bigint UNIQUE,
                constraint pk_students PRIMARY KEY(record_num))        
                ''')
        self.connection.commit()
        self.create_sort()
        self.create_absence()
        self.create_trigger_delete_student()

    def create_sort(self):
        self.cursor.execute('''
            create table sort(
            list_num serial,
            record_num bigint not null,
            name text not null,
            surname text not null,
            constraint pk_sort PRIMARY KEY(record_num),
            constraint fk_sort FOREIGN KEY(record_num) references students (record_num)
            on delete cascade on update cascade)
            ''')
        self.connection.commit()
        self.create_tirgger_add_sort()

    def create_tasks(self):
        self.cursor.execute('''
        create table tasks(
        task_id int generated by default as identity,
        date_given date,
        deadline date not null,
        description text not null,
        max_mark int DEFAULT 1,
        CONSTRAINT task_id_unique UNIQUE (task_id),
        constraint pk_tasks primary key(task_id, date_given),
        constraint positive_mark check(max_mark > 0))''')
        self.connection.commit()
        self.create_done_tasks()

    def create_done_tasks(self):
        self.cursor.execute('''
            create table done_tasks(
            task_id INT,
            record_num BIGINT not null,
            mark INT DEFAULT 0,
            constraint positive_mark check(mark >= 0),
            CONSTRAINT PK_DONE_TASKS PRIMARY KEY(task_id,record_num),
            CONSTRAINT FK_task_id FOREIGN KEY (task_id) REFERENCES tasks (task_id) ON DELETE CASCADE,
            CONSTRAINT FK_record_num FOREIGN KEY (record_num) REFERENCES students (record_num) ON DELETE CASCADE)
            ''')
        self.connection.commit()
        self.create_trigger_zeros_mark()
        self.create_trigger_new_user_to_tasks()

    def create_absence(self):
        self.cursor.execute('''
        create table absence(
        student bigint,
        date date,
        constraint pk_absence PRIMARY KEY(student),
        constraint fk_absence FOREIGN KEY(student) references students (record_num) ON DELETE CASCADE)''')
        self.connection.commit()

    # блок добавления
    def add_user(self, user_id, access_code):
        self.cursor.execute('''
        insert into access (user_id, code)
        values (%s,%s)''', (user_id, access_code))
        self.connection.commit()

    def add_position(self, user_id, pos):
        self.cursor.execute('''
        insert into position(user_id,pos)
        values (%s, %s)''', (user_id, pos))
        self.connection.commit()

    def add_student_out_id(self, name, surname, midname, record_num):
        self.cursor.execute('''
        insert into students(name, surname, midname, record_num)
        values (%s, %s, %s, %s)''', (name, surname, midname, record_num))
        self.connection.commit()

    def add_student_with_id(self, name, surname, midname, record_num, user_id):
        self.cursor.execute('''
                insert into students(name, surname, midname, record_num, user_id)
                values (%s, %s, %s, %s, %s)''', (name, surname, midname, record_num, user_id))
        self.connection.commit()

    def add_done_tasks(self, task_id, record_num, mark=1):
        self.cursor.execute('''
                INSERT INTO done_tasks
                VALUES (%s, %s, %s)''', (task_id, record_num, mark))
        self.connection.commit()

    def add_tasks(self, date_given, deadline, description, max_mark):
        self.cursor.execute('''
                insert into tasks(date_given, deadline, description, max_mark) 
                values(%s,%s,%s,%s)''', (date_given, deadline, description, max_mark))
        self.connection.commit()

    def add_sort(self):
        self.cursor.execute('''
            insert into sort(record_num, name, surname) 
            select record_num, name, surname 
            from students order by surname
            ''')
        self.connection.commit()

    def add_absence(self, student, date):
        self.cursor.execute('''
        insert into absence(student,date) values (%s,%s)''', (student, date))
        self.connection.commit()

    # блок апдеййта
    def update_position(self, user_id, pos):
        self.cursor.execute('''
        update position
        set pos = %s
        where user_id = %s''', (pos, user_id))
        self.connection.commit()

    def update_student_with_record(self, record_num, user_id, *name_sur_mid):
        name = name_sur_mid[0]
        surname = name_sur_mid[1]
        midname = name_sur_mid[2]
        self.cursor.execute('''
        update students
        set name = %s, surname = %s, midname = %s, user_id = %s
        where record_num = %s''', (name, surname, midname, user_id, record_num))
        self.connection.commit()

    def update_mark_of_task(self, task_id, record_num, mark):
        self.cursor.execute('''
        UPDATE done_tasks
        SET mark = %s
        WHERE task_id = %s AND record_num = %s;''', (mark, task_id, record_num))
        self.connection.commit()

    # блок селекта
    def find_user(self, user_id):
        # можно возвращать не пару юзер - доступ, а только доступ
        self.cursor.execute('''
        select * from access
        where user_id = %s''', (user_id,))
        return self.cursor.fetchone()

    def find_position(self, user_id):
        self.cursor.execute('''
        select pos from position
        where user_id = %s''', (user_id,))
        answer = self.cursor.fetchone()
        if answer is None:
            return None
        else:
            return answer[0]

    def find_student_with_record(self, record_num):
        self.cursor.execute('''
        select * from students
        where record_num = %s''', (record_num,))
        return self.cursor.fetchone()

    def find_student_with_userid(self, user_id):
        '''
        :param user_id:
        :return: (name, surname, midname, record_num, user_id):
        '''
        if user_id == None:
            return None
        self.cursor.execute('''
        select * from students
        where user_id = %s''', (user_id,))
        return self.cursor.fetchone()

    def find_student_not_none_userid(self):
        self.cursor.execute('''
            select user_id from students
            where user_id is not NULL''')
        return self.cursor.fetchall()

    def find_all_marks_with(self, task_id):
        '''
        return: (record_num, mark)
        '''
        self.cursor.execute('''
        select record_num, mark
        from done_tasks
        where task_id  = %s''', (task_id,))
        return self.cursor.fetchall()

    def find_last_task(self):
        self.cursor.execute('''
        select task_id, description, deadline
        from tasks
        where task_id = (select max(task_id) from tasks)''')
        return self.cursor.fetchone()

    def find_tasks_by_date(self, date_given):
        self.cursor.execute('''
        SELECT t.task_id, t.description, t.deadline, t.max_mark FROM tasks t
        WHERE date_given = %s''', (date_given,))
        return self.cursor.fetchall()

    def find_tasks(self):
        self.cursor.execute('''
        SELECT task_id, date_given, description FROM tasks''')
        return self.cursor.fetchall()

    # блок дропа
    def delete_user(self, user_id):
        self.cursor.execute('''
        delete from access
        where user_id = %s''', (user_id,))
        self.connection.commit()

    def delete_student_with_record(self, record_num):
        self.cursor.execute('''
        delete from students
        where record_num = %s''', (record_num,))
        self.connection.commit()

    def delete_student_with_userid(self, user_id):
        self.cursor.execute('''
        delete from students
        where user_id = %s''', (user_id,))
        self.connection.commit()

    def delete_absence(self, student):
        self.cursor.execute('''
                delete from absence
                where date = %s''', (student))
        self.connection.commit()

    def create_trigger_zeros_mark(self):
        self.cursor.execute('''
            CREATE OR REPLACE FUNCTION zero_m()
            RETURNS TRIGGER 
            LANGUAGE plpgsql 
            AS $$
            DECLARE
                task int;
            
            begin
                task = NEW.task_id;
                INSERT INTO done_tasks(task_id, record_num)
                select task, sort.record_num 
                from sort;
                return NEW;               
            end
            $$
        ''')
        self.cursor.execute('''
        create trigger zeros_marks
             after insert on tasks
             FOR EACH ROW EXECUTE procedure zero_m();
        ''')
        self.connection.commit()

    def create_trigger_new_user_to_tasks(self):
        self.cursor.execute('''
            CREATE OR REPLACE FUNCTION add_to_tasks()
            RETURNS TRIGGER 
            LANGUAGE plpgsql 
            AS $$
            DECLARE 
              record int;
            begin
                record = NEW.record_num;
                INSERT INTO done_tasks(task_id, record_num)
                select tasks.task_id, record
                from tasks;
                delete from sort;
                return NEW;
            end
            $$''')
        self.cursor.execute('''
                create trigger new_user_to_tasks
                after insert on students
                FOR EACH ROW EXECUTE procedure add_to_tasks();''')
        self.connection.commit()

    def create_tirgger_add_sort(self):
        self.cursor.execute('''
            CREATE OR REPLACE FUNCTION add_to_sort()
            RETURNS TRIGGER 
            LANGUAGE plpgsql 
            AS $$
            begin
                delete from sort;
                ALTER SEQUENCE sort_list_num_seq restart with 1;
                insert into sort(record_num, name, surname) 
                select record_num, name, surname 
                from students order by surname;
                return NEW;
            end
            $$''')
        self.cursor.execute('''
            create trigger new_user_sort
            after insert or update or delete on students
            FOR EACH STATEMENT EXECUTE procedure add_to_sort();''')
        self.connection.commit()

    def create_trigger_delete_student(self):
        self.cursor.execute('''
        CREATE OR REPLACE FUNCTION delete_student()
        RETURNS TRIGGER 
        LANGUAGE plpgsql 
        AS $$
        begin
            delete from access
            where user_id = OLD.user_id;
            return NEW;
        end
        $$''')
        self.cursor.execute('''
            create trigger delete_student
            after delete on students
            FOR EACH ROW EXECUTE procedure delete_student();''')
        self.connection.commit()

    # Учет баллов студента
    def accounting_mark(self, record_num):
        self.cursor.execute('''SELECT task_id, mark 
                        FROM done_tasks
                        WHERE %s = record_num''' % record_num)  # Производим запрос для учета баллов студента
        done = self.cursor.fetchall()
        sum_marks = 0  # сумма баллов набранные студентом
        max_marks = 0  # сумарно возможные баллы за задания
        for row in done:
            sum_marks += row[1]
            self.cursor.execute(''' SELECT max_mark FROM tasks WHERE %s=task_id LIMIT 1''' % row[
                0])  # Производим запрос для учета баллов максимального балла за все задания
            max_marks += self.cursor.fetchall()[0][0]
        return (sum_marks, max_marks)

    # Список должников
    def list_of_deptors(self, date_of_today):
        self.cursor.execute('''SELECT task_id
                        FROM tasks
                        WHERE deadline <= '%s' ''' % date_of_today)
        tasks = self.cursor.fetchall()
        record_well = []  # Cписок сделавших дз
        for task in tasks:
            self.cursor.execute('''SELECT task_id, record_num
                            FROM done_tasks
                            WHERE %s = task_id AND mark != 0  ''' % task[0])
            record_well += self.cursor.fetchall()

        self.cursor.execute('''	SELECT surname, name, record_num
                        FROM sort''')
        students = self.cursor.fetchall()  # Список всех студентов
        students_deptors = {}  # Список должников
        f = False  # Флажок состоит ли студент в списке без долгов
        for student in students:
            for row in record_well:
                # Проверяем состоит ли студент в списке без долгов а именно ячейками номеров зачеток
                if student[2] == row[1]:
                    f = True
                # Если студент не в списке успевающих, то добавляем в список должников
            if not f:
                if student[2] in students_deptors.keys():
                    students_deptors[student[2]] += student
                else:
                    students_deptors[student[2]] = student
            f = False
        return students_deptors
